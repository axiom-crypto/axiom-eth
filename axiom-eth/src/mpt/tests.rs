use super::*;
use crate::{
    halo2_proofs::{
        dev::MockProver,
        halo2curves::bn256::{Bn256, Fr, G1Affine},
        poly::commitment::ParamsProver,
        poly::kzg::{
            commitment::KZGCommitmentScheme,
            multiopen::{ProverSHPLONK, VerifierSHPLONK},
            strategy::SingleStrategy,
        },
        transcript::{
            Blake2bRead, Blake2bWrite, Challenge255, TranscriptReadBuffer, TranscriptWriterBuffer,
        },
    },
    keccak::{FixedLenRLCs, FnSynthesize, KeccakCircuitBuilder, VarLenRLCs},
    rlp::builder::RlcThreadBuilder,
    util::EthConfigParams,
};
use ark_std::{end_timer, start_timer};
use ethers_core::utils::keccak256;
use halo2_base::{
    halo2_proofs::plonk::{create_proof, keygen_pk, keygen_vk, verify_proof},
    utils::fs::gen_srs,
};
use hex::FromHex;
use rand_core::OsRng;
use std::{
    cell::RefCell,
    env::{set_var, var},
    fs::File,
    io::{BufReader, Write},
    path::Path,
};
use test_log::test;

fn test_mpt_circuit<F: Field>(
    k: u32,
    mut builder: RlcThreadBuilder<F>,
    inputs: MPTFixedKeyInput,
) -> KeccakCircuitBuilder<F, impl FnSynthesize<F>> {
    let prover = builder.witness_gen_only();
    let range = RangeChip::default(8);
    let mut keccak = KeccakChip::default();
    let mpt = EthChip::new(RlpChip::new(&range, None), None);
    let ctx = builder.gate_builder.main(0);
    let mpt_proof = inputs.assign(ctx);
    let mpt_witness = mpt.parse_mpt_inclusion_fixed_key_phase0(ctx, &mut keccak, mpt_proof);

    let circuit = KeccakCircuitBuilder::new(
        builder,
        RefCell::new(keccak),
        range,
        None,
        move |builder: &mut RlcThreadBuilder<F>,
              rlp: RlpChip<F>,
              keccak_rlcs: (FixedLenRLCs<F>, VarLenRLCs<F>)| {
            // hard to tell rust that &range lives long enough, so just remake the MPTChip
            let mut mpt = EthChip::new(rlp, None);
            mpt.keccak_rlcs = Some(keccak_rlcs);
            let (ctx_gate, ctx_rlc) = builder.rlc_ctx_pair();
            mpt.parse_mpt_inclusion_fixed_key_phase1((ctx_gate, ctx_rlc), mpt_witness);
        },
    );
    if !prover {
        let unusable_rows =
            var("UNUSABLE_ROWS").unwrap_or_else(|_| "109".to_string()).parse().unwrap();
        circuit.config(k as usize, Some(unusable_rows));
    }
    circuit
}

fn from_hex(s: &str) -> Vec<u8> {
    let s = if s.len() % 2 == 1 { format!("0{s}") } else { s.to_string() };
    Vec::from_hex(s).unwrap()
}

// The input file is generated by running `query_test.sh` in the `scripts/input_gen` directory of this repo
fn mpt_input(path: impl AsRef<Path>, slot_is_empty: bool, max_depth: usize) -> MPTFixedKeyInput {
    /*let block: serde_json::Value =
    serde_json::from_reader(File::open("scripts/input_gen/block.json").unwrap()).unwrap();*/

    let pf_str = std::fs::read_to_string(path).unwrap();
    let pf: serde_json::Value = serde_json::from_str(pf_str.as_str()).unwrap();
    // let acct_pf = pf["accountProof"].clone();
    let storage_pf = pf["storageProof"][0].clone();
    // println!("acct_pf {:?}", acct_pf);
    // println!("storage_root {:?}", pf["storageHash"]);
    // println!("storage_pf {:?}", storage_pf);

    let key_bytes_str: String = serde_json::from_value(storage_pf["key"].clone()).unwrap();
    let path = keccak256(from_hex(&key_bytes_str));
    let value_bytes_str: String = serde_json::from_value(storage_pf["value"].clone()).unwrap();
    let value_bytes_str = if value_bytes_str.len() % 2 == 1 {
        format!("0{}", &value_bytes_str[2..])
    } else {
        value_bytes_str[2..].to_string()
    };
    let value = ::rlp::encode(&from_hex(&value_bytes_str)).to_vec();
    let root_hash_str: String = serde_json::from_value(pf["storageHash"].clone()).unwrap();
    let pf_strs: Vec<String> = serde_json::from_value(storage_pf["proof"].clone()).unwrap();

    let value_max_byte_len = 33;
    let proof = pf_strs.into_iter().map(|pf| from_hex(&pf[2..])).collect();

    MPTFixedKeyInput {
        path: H256(path),
        value,
        root_hash: H256::from_slice(&from_hex(&root_hash_str[2..])),
        proof,
        value_max_byte_len,
        max_depth,
        slot_is_empty,
    }
}

fn default_input() -> MPTFixedKeyInput {
    mpt_input("scripts/input_gen/default_storage_pf.json", false, 8)
}

#[test]
pub fn test_mock_mpt_inclusion_fixed() {
    let params = EthConfigParams::from_path("configs/tests/mpt.json");
    // std::env::set_var("ETH_CONFIG_PARAMS", serde_json::to_string(&params).unwrap());
    let k = params.degree;
    let input = mpt_input("scripts/input_gen/default_storage_pf.json", false, 5); // depth = max_depth
    let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::mock(), input);
    MockProver::run(k, &circuit, vec![]).unwrap().assert_satisfied();

    let input = mpt_input("scripts/input_gen/default_storage_pf.json", false, 6); // depth != max_depth
    let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::mock(), input);
    MockProver::run(k, &circuit, vec![]).unwrap().assert_satisfied();
}

#[test]
pub fn test_mpt_noninclusion_branch_fixed() {
    let params = EthConfigParams::from_path("configs/tests/mpt.json");
    let k = params.degree;
    let input = mpt_input("scripts/input_gen/noninclusion_branch_pf.json", true, 5);
    let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::mock(), input);
    MockProver::run(k, &circuit, vec![]).unwrap().assert_satisfied();
}

#[test]
pub fn test_mpt_noninclusion_extension_fixed() {
    let params = EthConfigParams::from_path("configs/tests/mpt.json");
    let k = params.degree;
    let input = mpt_input("scripts/input_gen/noninclusion_extension_pf.json", true, 6); // require depth < max_depth
    let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::mock(), input);
    MockProver::run(k, &circuit, vec![]).unwrap().assert_satisfied();
}

#[test]
fn bench_mpt_inclusion_fixed() -> Result<(), Box<dyn std::error::Error>> {
    let bench_params_file = File::open("configs/bench/mpt.json").unwrap();
    std::fs::create_dir_all("data/bench")?;
    let mut fs_results = File::create("data/bench/mpt.csv").unwrap();
    writeln!(fs_results, "degree,total_advice,num_rlc_columns,num_advice,num_lookup,num_fixed,proof_time,verify_time")?;

    let bench_params_reader = BufReader::new(bench_params_file);
    let bench_params: Vec<EthConfigParams> = serde_json::from_reader(bench_params_reader).unwrap();
    for bench_params in bench_params {
        println!(
            "---------------------- degree = {} ------------------------------",
            bench_params.degree
        );
        // set_var("ETH_CONFIG_PARAMS", serde_json::to_string(&bench_params).unwrap());
        set_var("KECCAK_ROWS", bench_params.keccak_rows_per_round.to_string());
        let k = bench_params.degree;
        let params = gen_srs(k);
        let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::keygen(), default_input());
        // circuit.config(k as usize, Some(bench_params.unusable_rows));
        let vk = keygen_vk(&params, &circuit)?;
        let pk = keygen_pk(&params, vk, &circuit)?;
        let break_points = circuit.break_points.take();

        // create a proof
        let proof_time = start_timer!(|| "Create proof SHPLONK");
        let circuit = test_mpt_circuit(k, RlcThreadBuilder::<Fr>::prover(), default_input());
        assert_eq!(circuit.keccak.borrow().num_rows_per_round, bench_params.keccak_rows_per_round);
        *circuit.break_points.borrow_mut() = break_points;
        let mut transcript = Blake2bWrite::<_, _, Challenge255<_>>::init(vec![]);
        create_proof::<
            KZGCommitmentScheme<Bn256>,
            ProverSHPLONK<'_, Bn256>,
            Challenge255<G1Affine>,
            _,
            Blake2bWrite<Vec<u8>, G1Affine, Challenge255<G1Affine>>,
            _,
        >(&params, &pk, &[circuit], &[&[]], OsRng, &mut transcript)?;
        let proof = transcript.finalize();
        end_timer!(proof_time);

        let verify_time = start_timer!(|| "Verify time");
        let verifier_params = params.verifier_params();
        let strategy = SingleStrategy::new(&params);
        let mut transcript = Blake2bRead::<_, _, Challenge255<_>>::init(&proof[..]);
        verify_proof::<
            KZGCommitmentScheme<Bn256>,
            VerifierSHPLONK<'_, Bn256>,
            Challenge255<G1Affine>,
            Blake2bRead<&[u8], G1Affine, Challenge255<G1Affine>>,
            SingleStrategy<'_, Bn256>,
        >(verifier_params, pk.get_vk(), strategy, &[&[]], &mut transcript)
        .unwrap();
        end_timer!(verify_time);

        // auto generated
        let bench_params: EthConfigParams =
            serde_json::from_str(var("ETH_CONFIG_PARAMS").unwrap().as_str()).unwrap();
        let keccak_advice =
            std::env::var("KECCAK_ADVICE_COLUMNS").unwrap().parse::<usize>().unwrap();
        writeln!(
            fs_results,
            "{},{},{},{:?},{:?},{},{:.2}s,{:?}",
            bench_params.degree,
            bench_params.num_rlc_columns
                + bench_params.num_range_advice.iter().sum::<usize>()
                + bench_params.num_lookup_advice.iter().sum::<usize>()
                + keccak_advice,
            bench_params.num_rlc_columns,
            bench_params.num_range_advice,
            bench_params.num_lookup_advice,
            bench_params.num_fixed,
            proof_time.time.elapsed().as_secs_f64(),
            verify_time.time.elapsed()
        )
        .unwrap();
    }
    Ok(())
}
